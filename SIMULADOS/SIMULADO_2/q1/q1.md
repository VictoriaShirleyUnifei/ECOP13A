# 1a Questão:

Diga se a frase é verdadeira ou falsa: Caso seja falsa destacar o trecho
que a torna falsa.

a( V ) Ao menos um bloco catch deve vir após um bloco try, mas podem existir vários, um para
cada exceção que poderia ocorrer dentro do try.

b( F ) Em C++ **não é possível** derivar uma classe não template de uma classe template.

c( V ) Os Iteradores são componentes utilizados para percorrer os elementos de um contêiner da
mesma forma que um índice percorre os elementos de um array comum.

d( F ) Para lançar uma exceção em C++ utilizamos a palavra reservada **try**.

e( V ) Após tratada a exceção, o programa não retoma a execução do ponto onde parou, mas segue
sua execução a partir da primeira instrução após o último catch do bloco try.

f( F ) Uma exceção de uma classe mais genérica deve ser tratada por um bloco catch *antes* de uma
exceção mais específica.

g( V ) São exemplos de Containers Sequenciais: vector, deque, list e stack.

h( V ) O modelo de sintaxe para declarar uma função template é:
template <typename T> tipoRetorno NomeFunc( Parametros ){ .... }

i( V ) Todas as classes que derivam (direta ou indiretamente) de exception contém a função virtual
what(), que retorna a mensagem de erro de um objeto de exceção (string).

j( F ) A classe Stack da STL é um container de **1ª classe**.

k( V ) Contêineres são estruturas de dados que servem para armazenar valores (de tipos básicos
ou criados) e prover métodos de acesso, cada um segundo seu próprio tipo.

l( V ) Um pair é composto por dois itens, chamados de first e second.

m( F ) A classe da STL utilizada para a implementação de uma fila com prioridade é a **queue**.

n( V ) Os maps guardam pares ordenados compostos por uma chave e um valor.

o( V ) A definição de um gabarito de uma função começa com a palavra template, seguida da lista
de parâmetros de template.

p( V ) Utilizamos catch (...) para pegar qualquer exceção que foi lançada dentro de um bloco try.

q( V ) Considerando uma hierarquia de classes definida em C++, uma função virtual pura não
precisa ser implementada na classe base, para que objetos das classes derivadas tenham
acesso a ela.

r( V ) Em Orientação a Objetos a Resolução Dinâmica de Métodos permite que o programador crie
códigos genéricos que podem ser reaproveitados quando novas classes são inseridas na
hierarquia